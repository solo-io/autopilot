// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	context "context"

	client "sigs.k8s.io/controller-runtime/pkg/client"

	ezkube "github.com/solo-io/autopilot/pkg/ezkube"

	manager "sigs.k8s.io/controller-runtime/pkg/manager"

	mock "github.com/stretchr/testify/mock"
)

// Ensurer is an autogenerated mock type for the Ensurer type
type Ensurer struct {
	mock.Mock
}

// Create provides a mock function with given fields: ctx, obj
func (_m *Ensurer) Create(ctx context.Context, obj ezkube.Object) error {
	ret := _m.Called(ctx, obj)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ezkube.Object) error); ok {
		r0 = rf(ctx, obj)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: ctx, obj
func (_m *Ensurer) Delete(ctx context.Context, obj ezkube.Object) error {
	ret := _m.Called(ctx, obj)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ezkube.Object) error); ok {
		r0 = rf(ctx, obj)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Ensure provides a mock function with given fields: ctx, parent, child, reconcileFuncs
func (_m *Ensurer) Ensure(ctx context.Context, parent ezkube.Object, child ezkube.Object, reconcileFuncs ...ezkube.ReconcileFunc) error {
	_va := make([]interface{}, len(reconcileFuncs))
	for _i := range reconcileFuncs {
		_va[_i] = reconcileFuncs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, parent, child)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ezkube.Object, ezkube.Object, ...ezkube.ReconcileFunc) error); ok {
		r0 = rf(ctx, parent, child, reconcileFuncs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, obj
func (_m *Ensurer) Get(ctx context.Context, obj ezkube.Object) error {
	ret := _m.Called(ctx, obj)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ezkube.Object) error); ok {
		r0 = rf(ctx, obj)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// List provides a mock function with given fields: ctx, obj, options
func (_m *Ensurer) List(ctx context.Context, obj ezkube.List, options ...client.ListOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, obj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ezkube.List, ...client.ListOption) error); ok {
		r0 = rf(ctx, obj, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager provides a mock function with given fields:
func (_m *Ensurer) Manager() manager.Manager {
	ret := _m.Called()

	var r0 manager.Manager
	if rf, ok := ret.Get(0).(func() manager.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(manager.Manager)
		}
	}

	return r0
}

// Update provides a mock function with given fields: ctx, obj, reconcileFuncs
func (_m *Ensurer) Update(ctx context.Context, obj ezkube.Object, reconcileFuncs ...ezkube.ReconcileFunc) error {
	_va := make([]interface{}, len(reconcileFuncs))
	for _i := range reconcileFuncs {
		_va[_i] = reconcileFuncs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, obj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ezkube.Object, ...ezkube.ReconcileFunc) error); ok {
		r0 = rf(ctx, obj, reconcileFuncs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateStatus provides a mock function with given fields: ctx, obj
func (_m *Ensurer) UpdateStatus(ctx context.Context, obj ezkube.Object) error {
	ret := _m.Called(ctx, obj)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ezkube.Object) error); ok {
		r0 = rf(ctx, obj)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
