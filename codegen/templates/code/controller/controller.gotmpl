// Definitions for the Kubernetes Controllers
package controller

import (
    "context"
    "sync"

    . "{{ group_import_path $ }}"
    "github.com/pkg/errors"
    "github.com/solo-io/autopilot/pkg/events"
    "github.com/solo-io/autopilot/pkg/mutlicluster"
    "k8s.io/apimachinery/pkg/runtime"
    "sigs.k8s.io/controller-runtime/pkg/manager"
    "sigs.k8s.io/controller-runtime/pkg/predicate"
)

{{- range $resource := $.Resources }}

type {{ $resource.Kind }}EventHandler interface {
    Create(obj *{{ $resource.Kind }}) error
    Update(old, new *{{ $resource.Kind }}) error
    Delete(obj *{{ $resource.Kind }}) error
    Generic(obj *{{ $resource.Kind }}) error
}

type {{ $resource.Kind }}EventHandlerFuncs struct {
    OnCreate  func(obj *{{ $resource.Kind }}) error
    OnUpdate  func(old, new *{{ $resource.Kind }}) error
    OnDelete  func(obj *{{ $resource.Kind }}) error
    OnGeneric func(obj *{{ $resource.Kind }}) error
}

func (f *{{ $resource.Kind }}EventHandlerFuncs) Create(obj *{{ $resource.Kind }}) error {
    if f.OnCreate == nil {
        return nil
    }
    return f.OnCreate(obj)
}

func (f *{{ $resource.Kind }}EventHandlerFuncs) Delete(obj *{{ $resource.Kind }}) error {
    if f.OnDelete == nil {
        return nil
    }
    return f.OnDelete(obj)
}

func (f *{{ $resource.Kind }}EventHandlerFuncs) Update(objOld, objNew *{{ $resource.Kind }}) error {
    if f.OnUpdate == nil {
        return nil
    }
    return f.OnUpdate(objOld, objNew)
}

func (f *{{ $resource.Kind }}EventHandlerFuncs) Generic(obj *{{ $resource.Kind }}) error {
    if f.OnGeneric == nil {
        return nil
    }
    return f.OnGeneric(obj)
}

type {{ $resource.Kind }}Controller struct {
    watcher events.EventWatcher
}

func New{{ $resource.Kind }}Controller(mgr manager.Manager, opts events.WatcherOpts) (*{{ $resource.Kind }}Controller, error) {
    if err := AddToScheme(mgr.GetScheme()); err != nil{
        return nil, err
    }

    w, err := events.NewWatcher(mgr, opts)
    if err != nil {
        return nil, err
    }
    return &{{ $resource.Kind }}Controller{
        watcher: w,
    }, nil
}

func (c *{{ $resource.Kind }}Controller) AddEventHandler(ctx context.Context, h {{ $resource.Kind }}EventHandler, predicates ...predicate.Predicate) error {
	handler := generic{{ $resource.Kind }}Handler{handler: h}
    if err := c.watcher.Watch(ctx, &{{ $resource.Kind }}{}, handler, predicates...); err != nil{
        return err
    }
    return nil
}

// generic{{ $resource.Kind }}Handler implements a generic events.EventHandler
type generic{{ $resource.Kind }}Handler struct {
    handler {{ $resource.Kind }}EventHandler
}

func (h generic{{ $resource.Kind }}Handler) Create(object runtime.Object) error {
    obj, ok := object.(*{{ $resource.Kind }})
    if !ok {
        return errors.Errorf("internal error: {{ $resource.Kind }} handler received event for %T")
    }
    return h.handler.Create(obj)
}

func (h generic{{ $resource.Kind }}Handler) Delete(object runtime.Object) error {
    obj, ok := object.(*{{ $resource.Kind }})
    if !ok {
        return errors.Errorf("internal error: {{ $resource.Kind }} handler received event for %T")
    }
    return h.handler.Delete(obj)
}

func (h generic{{ $resource.Kind }}Handler) Update(old, new runtime.Object) error {
    objOld, ok := old.(*{{ $resource.Kind }})
    if !ok {
        return errors.Errorf("internal error: {{ $resource.Kind }} handler received event for %T")
    }
    objNew, ok := new.(*{{ $resource.Kind }})
    if !ok {
        return errors.Errorf("internal error: {{ $resource.Kind }} handler received event for %T")
    }
    return h.handler.Update(objOld, objNew)
}

func (h generic{{ $resource.Kind }}Handler) Generic(object runtime.Object) error {
    obj, ok := object.(*{{ $resource.Kind }})
    if !ok {
        return errors.Errorf("internal error: {{ $resource.Kind }} handler received event for %T")
    }
    return h.handler.Generic(obj)
}


type Managed{{ $resource.Kind }}Controller struct {
	  mgr  *multicluster.ContextualManager
	  ctrl *{{ $resource.Kind }}Controller
}

type MultiCluster{{ $resource.Kind }}Controller struct {
	  handler {{ $resource.Kind }}EventHandler

    ctx         context.Context
    ctrlLock    sync.RWMutex
    controllers map[string]*Managed{{ $resource.Kind }}Controller
}

func (m *MultiCluster{{ $resource.Kind }}Controller) ClusterAdded(mgr *multicluster.ContextualManager,
    name string) error {

    mcCtrl, err := m.addCluster(mgr, name, name)
    if err != nil {
        return err
    }

    m.ctrlLock.Lock()
    defer m.ctrlLock.Unlock()
    m.controllers[name] = &Managed{{ $resource.Kind }}Controller{
        mgr:  mcCtrl.mgr,
        ctrl: mcCtrl.ctrl,
    }
    return nil
}

func (m *MultiCluster{{ $resource.Kind }}Controller) addCluster(mgr *multicluster.ContextualManager,
    cluster, name string) (*Managed{{ $resource.Kind }}Controller, error) {

    ctrl, err := New{{ $resource.Kind }}Controller(mgr.Manager(), events.WatcherOpts{
        Name:    name,
        Cluster: cluster,
    })
    if err != nil {
        return nil, err
    }
    if err := ctrl.AddEventHandler(m.ctx, m.handler); err != nil {
        return nil, err
    }

    return &Managed{{ $resource.Kind }}Controller{
        mgr:  mgr,
        ctrl: ctrl,
    }, nil
}

func (m *MultiCluster{{ $resource.Kind }}Controller) ClusterRemoved(name string) error {
    m.ctrlLock.Lock()
    defer m.ctrlLock.Unlock()
    mgr, ok := m.controllers[name]
    if !ok {
        return eris.Errorf("could not find controller for cluster %s", name)
    }
    go mgr.mgr.Stop()
    delete(m.controllers, name)
    return nil
}

// The mgr arg here should be the local cluster manager
func NewMultiCluster{{ $resource.Kind }}Controller(ctx context.Context, mgr manager.Manager,
    handler {{ $resource.Kind }}EventHandler) (*MultiCluster{{ $resource.Kind }}Controller, error) {

    mcCtrl := &MultiCluster{{ $resource.Kind }}Controller{
        handler:     handler,
        ctx:         ctx,
        ctrlLock:    sync.RWMutex{},
        controllers: make(map[string]*Managed{{ $resource.Kind }}Controller),
    }

    ctxMgr := multicluster.NewContextualManager(ctx, mgr)
    localController, err := mcCtrl.addCluster(ctxMgr, "", "local-{{ $resource.Kind }}-controller")
    if err != nil {
      return nil, err
    }
    mcCtrl.controllers[""] = localController
    return mcCtrl, nil
}
{{- end }}
